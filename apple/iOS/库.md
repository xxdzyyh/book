## 库

[TOC]

Libraray:编译好的二进制代码,只需要 Link 一下就可以，将稳定的代码打包成库。

iOS8之后，iOS有了App Extesion特性，而且Swift也诞生了。

由于iOS主App需要和Extension共享代码，Swift语言机制也需要动态库，于是苹果后来提出了Embedded Framework，这种动态库允许APP和APP Extension共享代码，但是这份动态库的生命被限定在一个APP进程内。

在Swift的项目中如果要在项目中使用外部的代码，可选的方式只有两种，一种是把代码拷贝到工程中，另一种是用动态 Framework。**使用静态库是不支持的**。这个问题的根本原因主要是 Swift 的运行库没有被包含在 iOS 系统中，而是会打包进 App 中（这也是造成 Swift App 体积大的原因），**静态库会导致最终的目标程序中包含重复的运行库**



### 静态库

App 自身的代码被编译成目标文件后，通过静态链接器将App的目标文件与静态库合并，并生成的可执行文件。这样，App 自身代码生成的目标文件与静态库都被拷贝到可执行文件中，从而静态库也成为了 App 可执行文件的一部分。

使用 MachOView 查看的时候，Load Commands 里是找不到静态库的，但是可以找到动态库。





![static Library](/Users/mac/WorkSpace/book/apple/iOS/raw/static Library.png)





### 动态库静态库启动时间



动态库 *dynamic shared libraries*, *shared objects*, or *dynamically linked libraries*。我们以 OS X 为例，当 App 启动时，操作系统内核会将 App 代码和数据载入新进程(*也就是操作系统为 App 创建的新进程*)的地址空间。与此同时呢，操作系统内核也会把**动态加载器**(*Dynamic Loader*) 载入进程，由**动态加载器**来完成加载 App 依赖的动态库。不过在启动阶段，**动态加载器**只会根据**静态链接器**中记录的 App 已链接的依赖库的名字，然后使用依赖库的 `install name` 来查找它们是否在文件系统中存在。如果不存在或不兼容，App 启动过程会中断。动态库被完全载入内存，是在代码里使用它的时候。所以相对静态库来说，使用动态库链接的 App 启动过程会更快。

### iOS的.framework，如何区分是动态库还是静态库？

```
file FBRetainCycleDetector.framework/FBRetainCycleDetector

Mach-O universal binary with 4 architectures: [i386:Mach-O dynamically linked shared library i386] [x86_64:Mach-O 64-bit dynamically linked shared library x86_64] [arm_v7:Mach-O dynamically linked shared library arm_v7] [arm64]
```

### 查看framework或者.a是否包含bitcode 

```
// 如果字段大于1，则包含bitcode
otool -arch armv7 -l xx.framework/xx | grep __bundle
otool -arch armv7 -l xx.a | grep __bitcode
```

### 剥离构架相关代码

```
lipo -info FB.framework/FB

Architectures in the fat file: FB.framework/FB are: armv7 arm64 

// 删除架构
lipo FB.framework/FB -remove arm64 -output FB.framework/FB
```

### 合并

```
lipo -create /Users/zyh/Desktop/libSyncSDK.i386.a /Users/zyh/Desktop/libSyncSDK.arm.a -output /Users/zyh/Desktop/libSyncSDK.a
```



XCode12之前：
编译模拟器静态库支持i386 x86_64两架构
编译真机静态库支持armv7 arm64两架构
使用lipo -create -output命令可以将两个库合并成一个支持模拟器和真机i386 x86_64 armv7 arm64四种架构的胖子库。

XCode12编译的模拟器静态库也支持了arm64，导致出现真机库和模拟器库不能合并的问题。

 

### dSYM

静态库编译没有单独的dSYM，因为静态库不是一个真正的可执行文件，最后会被包含的依赖这个静态库的文件中，所以不会有的单独的符号表。

Static lib symbols *do* show up in an app's dSYM file, and dwarfdump will reveal that.

```
 dwarfdump -a path/to/app.dSYM >dsymAsText.txt
```

```
However if you are (as I have been recently) looking for a symbol table to be generated to go along with just your static lib, I have come to the conclusion that it will be fairly useless; once it get compiled into a new app those symbols and addresses will all change and you will have an entirely different offset for everything (please someone correct me if I'm wrong).
```





#  luject

https://zhuanlan.zhihu.com/p/136608227