### 中间件

页面跳转在应用中是很常见的。假设A、B、C都可以跳到D页面，我们可以在A、B、C中引用D，然后创建一个实例跳过去。但是如果现在新增一个需求，跳到D前先要判断一下用户是否登录过了，登录过了才跳到D，否者去登录，那A、B、C中跳转到D的方法就都需要修改了。我们可以使用一个中间件，就叫Router好了，在Router中添加一个方法pushToPageD。A、B、C引用Router,让后调用Router的pushToPageD方法去跳转。后续假设进入D这个逻辑方法了变化，比如竖屏才进入D，横屏进入E，这个时候，修改一下pushToPageD方法就可以了。我们可以将所有的跳转逻辑都放在Router中（依据实际情况）。

假设某天我们要将A、B、C所在的业务作为一个模块，D所在的业务作为一个单独模块，那这个时候Router就成为了最大的障碍，因为Router是直接引用了A、B、C、D、E的，

直接把Router干掉肯定是不行的，因为Router的作用是存在的。那只能去掉Router对A、B、C、D、E的直接引用，把Router中跳转的实现分到各个模块中，也就是将Router拆分成多个子Router,Router自身只剩一些和业务无关的代码。

* 委托模式 

  去掉了对A、B、C、D、E的直接引用，就意味着没法直接跳过去。Router知道何时需要跳转，但是不知道如何跳转，那跳转可以让代理去做。每个某块将自己设置为Router的代理，Router需要跳转时，可以转发给自己的那些代理，谁可以处理就去处理。很多路由需要注册如( [JLRoutes](https://github.com/joeldev/JLRoutes) 、MGJRouter)，其实就是一种委托的形式。

* runtime

  基于语言特性去做解耦。如果某个模块允许外界跳转进来，那这个模块就需要维持一个对外暴露的接口，外界引用这个暴露的接口就可以。这种情况就相当于将最初的那个引用了A、B、C、D、E的Router拆分成了多个子Router。仅仅这样做还是不行的，因为不同模块间不允许任何直接引用。我们可以直接使用Runtime来动态调用其他模块Router的方法，但是这样风险很大，也违背了初衷，你必须对着其他模块的代码才能写出runtime调用。这种情况和之前类似，也就是还需要加一个中间层来解决问题。每个模块的开发者创建一个新的中间层，新的中间层通过runtime调用模块Router，不直接引用模块代码，其他的模块引用新的中间层，调用新的中间层代码。
  

### 远程调用和本地调用

iOS远程调用都是通过url实现的，远程调用最终还是要转换成本地调用，也就是远程调用是本地调用的子集，所以本地调用如果也用url去做，变成远程调用，有点舍近求远的意思。

### 值参数和对象参数

url形式跳转一个问题是只能传简单类型的参数，不能传递对象比如UIImage对象，不支持传递对象的Router肯定是有问题的，一般就需要额外添加一个参数如NSDictionary对象，将对象传递过去。

```
+[Router handleURL: ]
+[Router handleURL: withParams:]
```

传递参数如果放在NSDictionary里，调用者很难知道要传什么东西过去。



### 是否需要注册

Router不直接引用模块代码，要处理跳转就只能走代理模式，这个时候就需要一个设置代理的步骤，一般都是注册，将特定的URL和block绑定，收到处理URL请求时，调用与之对应的block。

```
[Router registerURL: withHandle:^(NSDictionary *params) { 
		// 跳转具体实现
}];
```

如果使用runtime,这个注册过程是不需要的，因为模块的提供者的提供了一个新的中间层供外界使用,这个新的中间层是利用runtime进行调用的。

注册方式是比较容易理解的，但是会有一些问题，一般注册过程都是放在+load中的 ,这会导致启动时间变长。程序想要运行，每个类必须先load进去。注册会消耗一定的额外内存。过时注册很容易忘记删除。

```
// Router.m
+ (void)load {
	[Router registerURL:@"A://B/C" withHandle:^(NSDictionary *params) { 
		// 跳转具体实现
	}];
}
```





















