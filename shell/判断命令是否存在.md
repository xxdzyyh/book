## 判断命令是否存在

一般情况，我们可以使用 `command --version`去查看有没有安装成功，但是如果command 不支持 --version,这种判断就会失效。

我们可以使用`type`命令来判断，`type` 是 shell 内建的命令。`which`有些系统是内建命令，有些不是。

```
$ type type
type is a shell builtin

$ type undefineCommand
undefineCommand not found
```

```
function checkInstall() {
	type $1 > /dev/null 2>&1
	// $? -eq 0 判断上一条命令有没有执行成功，shell里默认0是成功，其他值为失败
	if [ $? -eq 0 ] 
	then 
		echo "√ $1 已经安装"
	else
		echo "× $1 没有安装"
	fi
}

checkInstall 'mysql'
checkInstall 'java'
checkInstall 'node'
```

```
$ sh /Users/mac/WorkSpace/BugInsight安装包及部署文档/check_evn.sh 

√ mysql 已经安装
√ java 已经安装
√ node 已经安装
```



### 文件描述符

当执行shell命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：

| 类型                        | 文件描述符 | 默认情况               | 对应文件句柄位置 |
| --------------------------- | ---------- | ---------------------- | ---------------- |
| 标准输入（standard input）  | 0          | 从键盘获得输入         | /proc/slef/fd/0  |
| 标准输出（standard output） | 1          | 输出到屏幕（即控制台） | /proc/slef/fd/1  |
| 错误输出（error output）    | 2          | 输出到屏幕（即控制台） | /proc/slef/fd/2  |

所以我们平时在执行shell命令中，都默认是从键盘获得输入，并且将结果输出到控制台上。但是我们可以通过更改文件描述符默认的指向，从而实现输入输出的重定向。比如我们将1指向文件，那么标准的输出就会输出到文件中。

## 输出重定向

输出重定向的使用方式很简单，基本的一些命令如下：

| 命令                | 介绍                       |
| ------------------- | -------------------------- |
| command >filename   | 把标准输出重定向到新文件中 |
| command 1>filename  | 同上                       |
| command >>filename  | 把标准输出追加到文件中     |
| command 1>>filename | 同上                       |
| command 2>filename  | 把标准错误重定向到新文件中 |
| command 2>>filename | 把标准错误追加到新文件中   |

我们使用`>`或者`>>`对输出进行重定向。符号的左边表示文件描述符，**如果没有的话表示1，也就是标准输出**，符号的右边可以是一个文件，也可以是一个输出设备。当使用`>`时，会判断右边的文件存不存在，如果存在的话就先删除，然后创建一个新的文件，不存在的话则直接创建。但是当使用`>>`进行追加时，则不会删除原来已经存在的文件。



## 输入重定向

在理解了输出重定向之后，理解输入重定向就会容易得多。对输入重定向的基本命令如下：

| 命令                | 介绍                                      |
| ------------------- | ----------------------------------------- |
| command <filename   | 以filename文件作为标准输入                |
| command 0<filename  | 同上                                      |
| command <<delimiter | 从标准输入中读入，直到遇到delimiter分隔符 |

我们使用`<`对输入做重定向，**如果符号左边没有写值，那么默认就是0**。

```
// 从input文件中读取内容，写入到out文件中
$ cat >out <input

```

### 重定向绑定

好了，在有了以上知识的基础上，我们再来看开头提到的`>/dev/null 2>&1`。这条命令其实分为两命令，一个是`>/dev/null`，另一个是`2>&1`。

#### 1. >/dev/null

这条命令的作用是将标准输出1重定向到/dev/null中。/dev/null代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了`>/dev/null`之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。

#### 2. 2>&1

这条命令用到了重定向绑定，采用&可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。

linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以`>/dev/null 2>&1`的作用就是让标准输出重定向到/dev/null中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了/dev/null中，错误输出同样也被丢弃了。执行了这条命令之后，**该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中**。

| 命令            | 标准输出 | 错误输出 |
| --------------- | -------- | -------- |
| >/dev/null 2>&1 | 丢弃     | 丢弃     |
| 2>&1 >/dev/null | 丢弃     | 屏幕     |

```
>/dev/null 2>&1
1>/dev/null 2>&1

1重定向到了/dev/null，2绑定1，2也指向/dev/null，标准输出和错误输出都被丢弃了


2>&1 >/dev/null
2>&1 1>/dev/null

2绑定1,1现在指向默认的输出，屏幕。然后 1>/dev/null，1重定向了/dev/null，说以标准输出被丢弃了，错误信息输出到了屏幕
```

